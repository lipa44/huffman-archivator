# Отчёт по ЛР 1

Студент: **Либченко Михаил Вадимович**, **M4106**

Алгоритм: **Код Хаффмана двухпроходный, блоками по 2 символа**

## Запуск .exe _(может не сработать)_

```shell
cd /exec
```

### Win-x64

```shell
./Archivator_win-x64 [encoder|decoder] [inputPath] [outputPath]
```

### Win-x86

```shell
./Archivator_win-x86 [encoder|decoder] [inputPath] [outputPath]
```

### Win-arm64

```shell
./Archivator_win-arc64 [encoder|decoder] [inputPath] [outputPath]
```

## Запуск c dotnet

> Необходим установленный [.NET 9 SDK](https://dotnet.microsoft.com/en-us/download/dotnet/9.0) на компьютере

```shell
dotnet build -c Release
dotnet publish -c Release
```

```shell
dotnet run --project Archivator [encoder|decoder] [inputPath] [outputPath]
```

## Энкодер

### Этапы кодирования

1. **Построение частотной таблицы:**
   Файл разбивается на пары байтов (2-байтовые блоки). Каждая пара интерпретируется как 16-битное число `ushort`. Для
   всех таких пар считается частота появления.

2. **Построение дерева Хаффмана:**
   Для построения дерева используется приоритетная очередь (`PriorityQueue`). Каждая пара добавляется в очередь как лист
   дерева. На каждом шаге извлекаются 2 узла с наименьшими частотами и объединяются в нового родителя. Этот процесс
   повторяется до тех пор, пока не останется один корневой узел.

3. **Назначение кодов Хаффмана:**
   Проходом по каждому символу _(паре байтов)_ дерева и назначаем ей уникальную последовательность битов. Для левого
   ребра добавляется `0`, для правого - `1`.

4. **Кодирование данных:**
   Исходный файл снова разбивается на пары. Каждая пара заменяется соответствующим кодом Хаффмана. Последний одиночный
   байт (если есть) также кодируется как пара с `0x00`.

5. **Преобразование битовой строки в массив байтов:**
   Полученная строка битов разбивается на байты. Если в последнем байте недостаточно бит, он дополняется нулями.

6. **Формирование архива:**
   В выходной файл в указанном порядке записываются следующие данные:
    - Количество уникальных пар
    - Частотная таблица
    - Оригинальная длина входного файла
    - Длина сжатых данных
    - Сами сжатые данные

## Декодер

### Этапы декодирования

1. **Чтение заголовка архива:**
   Из архива считывается в указанном порядке следующие данные:
    - Количество уникальных пар
    - Частотная таблица
    - Оригинальная длина входного файла
    - Длина сжатых данных
    - Сами сжатые данные

2. **Построение дерева Хаффмана:**
   Аналогично кодеру, дерево восстанавливается из частотной таблицы.

3. **Побитовая декомпрессия:**
   Поток сжатых данных читается побитно. Для каждой последовательности битов происходит переход по дереву Хаффмана. Как
   только достигается лист _(восстановленная пара байтов)_, эта пара добавляется в выходной массив.

4. **Ограничение по длине:**
   В процессе восстановления учитывается оригинальный размер входного файла. Если последний блок был неполным _(
   например, состоял только из одного байта + фиктивный `0x00`)_, то при декодировании второй байт просто не
   записывается.

## Результаты сжатия

> Суммарное значение сжатого размера всех файлов: **1_545_175 байт**